## 引言
学习了操作系统和计算机组成原理之后，我们发现计算机经过多年的发展和技术迭代，改进出各种有用的机制，保证操作系统的稳定性和安全性，比如虚拟内存的设计让计算机能够运行大于物理内存的程序，同时为进程提供对内存的抽象，对进程间进行隔离。
善于观察的同学就会发现，进程的隔离是普遍的，但是也有一些程序，他们作为一个运行在操作系统上的普通程序，却可以拥有更强大的能力。比如我们使用的 ”gdb“和”任务管理器“。更生动的一个例子是“游戏修改器”，也就是俗称的开挂。为什么游戏修改器能够修改正在运行的游戏的数据？这是一个值得思考的问题。
我们将通过几个实验，来探究这个过程。
## 虚拟内存提供的进程隔离
在程序A中分配一个内存地址，并为设置一个初始值，同时在程序B中访问这个相同的内存地址，能访问成功吗？访问的是同一个值吗？
1. 根据所学知识，给出你的答案。
2. 写出程序验证你的答案。
3. process_protect demo
## 入侵地址空间的案例
### pmap命令的使用
 > pmap - report memory map of a process
 >  **pmap** [_option_ ...] _pid_ ...
 
 Linux为我们提供了pmap命令，阅读文档可以发现，此命令的作用是报告进程的内存映射，通过此命令，我们可以进一步窥探进程的内存布局：
1. 阅读[pmap](https://man7.org/linux/man-pages/man1/pmap.1.html)的文档和相关资料，使用pmap多次查看不同进程的地址空间
2. 分析pmap的输出结果，思考：
	1. pamp输出的每一列的意义是什么？
	2. pamp输出的每一行之间的区别是什么？
	3. 自己有没有感兴趣的点？
### [gdb](https://www.sourceware.org/gdb/)的使用
相信大家都有过调试程序的经历，通常都是在IDE中设置断点，点击debug，就可以开始各种调试，单步运行，堆栈跟踪，查看变量值等。但是VSCode 本身不包含一个内建的调试器，而是通过调试适配器协议（Debug Adapter Protocol, DAP）与各种调试器进行通信。GDB就是一个常见的后端调试器。
1. GDB提供了很多丰富的功能，如打印变量值，打印寄存器的值，尝试使用GDB调试简单的程序，探索GDB的这些功能
2. 思考和讨论：GDB的这些功能违反进程隔离的策略吗？
### 游戏修改器
游戏修改器是玩家在单机游戏中常用的工具，可以帮助他们自定义和增强游戏体验。【并不赞同联机游戏使用游戏修改器，破坏游戏平衡，会被人叫做挂狗】常见游戏修改器有CE修改器，金山游侠，WeMod等。这些修改器通过简单的按键操作，就可以实现修改游戏属性(血量，攻击等)，也可以改变游戏的时间流逝速度，做到快速跑图。
### CE的简单使用
我们可以简单玩一玩游戏修改器，这里推荐的是[Cheat Engine](https://www.cheatengine.org/)，直接点击链接下载对应的安装包【注意，官网的安装包也会有捆绑软件，安装的时候小心】，安装成功后，cheat engine会贴心的给我们打开一个游戏(简单的一个猜数程序吧)，然后利用这个程序教我们如何使用【自带教程的良心软件】。
1. 使用cheat engine修改一个游戏的属性
2. 在熟悉了cheat engine的基本使用之后，进一步思考：
	1. cheat engine只能修改游戏吗？
		1. 事实上，它不仅仅是一个简单的游戏修改器，还是一个厉害的调试器，可以使用java, lua, c#编写插件，还有内存补丁，系统检查工具，变速等功能
		2. 这些功能都是操作系统希望看到的吗？符合进程隔离的策略吗？
## 打破常规，入侵进程的地址空间
看完前面的案例，我们可以笃定，计算机一方面提供了虚拟内存的机制，使得进程地址空间相互隔离，另一方面，操作系统留了一定的手段，供开发调试，系统监控使用。我们可以查找这些手段，做些有意思的事情，比如模仿Cheat Engine，自己做一个简单的游戏修改器。
### 操作系统的后门
当我们得到了很多关于跨进程读取的信息后，我们当然可以知道操作系统为了方便开发调试等目的，留下了能够跨进程读取内存的后门，不妨自己想一想，**如果是你来设计，你会怎么留下这一道危险的后门。**
当然，想不出来也没有关系，我们可以查资料。接下来，你可以使用Google，去图书馆找书，尝试自己找到操作系统留下的跨进程读取的后门。并总结下来。如果你上一步有自己的想法，查完 资料之后，你的想法是对的吗？如果你的想法还没有被操作系统实现，你也可以重新思考一下你的方案的可行性，并且和同学老师学长讨论，最后，你不妨试着自己实现一下呢。
### Debug API
### [proc_pid_mem](https://man7.org/linux/man-pages/man5/proc_pid_mem.5.html)
#### mem的基本知识
> _/proc/_pid_/mem_
              This file can be used to access the pages of a process's
              memory through [open(2)](https://man7.org/linux/man-pages/man2/open.2.html), [read(2)](https://man7.org/linux/man-pages/man2/read.2.html), and [lseek(2)](https://man7.org/linux/man-pages/man2/lseek.2.html).

这是Linux系统留下的一个后门，如果你找到了，说明你自主搜索的能力还不错。尝试了解这个文件是干什么的，它能帮助我们实现跨进程读取内存吗？
#### mem使用
通过前面的探索，我们发现mem是一个特殊的文件，可以让通过open , read 访问进程的页面。接下来的任务就显而易见了，既然是一个文件，那么就可以使用基本的文件操作来读取内容。
1. 尝试读取mem的内容。
	1. 在命令行里面查看文件的基本操作，有file, cat，对mem使用这些命令并查看结果，mem是普通的文件吗？
	2. 尝试利用文件读写操作读取mem，有了1中的探索，相信你如果遇到读取文件失败也不会惊讶了吧。思考为什么文件会读取失败，试着自己找答案解决，实在没有思路就继续往下看吧。
2. 开始读取mem的内容
3. 如果你查看过/proc的man page, 你会发现文档对这个文件的介绍是伪文件系统
>    The **proc** filesystem is a pseudo-filesystem which provides an
       interface to kernel data structures.  It is commonly mounted at
       _/proc_.

换句话说mem也并不是一个普通的文件。同时，如果你仔细思考过就会发现许多证据，file命令查看mem的时候返回empty, mem是对一个进程的地址空间的抽象，回忆虚拟内存的知识，对于64位操作系统的地址空间有多大？不可能全部映射到一个文件。一个可能的假设就是操作系统只会把已经分配的地址映射到mem中，那么如何知道操作系统映射了哪些地址呢？pmap。
了解了这些，现在请你尝试再次读取进程的地址空间吧。
4. 如果能够读取mem中的内容，那么恭喜你。但是我们并不止步于此，为了实现Cheat engine类似的功能，我们还需要实现查找和替换功能。